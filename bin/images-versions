#!node

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const BASE_K8S_MANIFEST_PATH = path.join(process.env.WORKSPACE, 'packlink', 'k8s-manifests');

function extractImageAndVersion(imageAndVersion) {
    return imageAndVersion.replace('&deployment_image', '').replace('eu.gcr.io/packlink-tools/', '').trim().split(':');
}

function getAllImagesAndVersionsFromEnv() {
    const pods = execSync(
        'kubectl get pods -n microservices -o jsonpath="{.items[*].spec.containers[*].image}"',
    ).toString();
    return pods.split(/\s/).map((img) => extractImageAndVersion(img));
}

function getImageAndVersionFromPath(filePath) {
    if (fs.existsSync(filePath)) {
        const fileContent = fs.readFileSync(filePath, 'utf8');
        return extractImageAndVersion(fileContent.match(/image:\s(.*)/)[1]);
    }
    return null
}

function getMicroserviceListFromManifest() {
    const microservicePath = path.join(BASE_K8S_MANIFEST_PATH, 'microservices');
    const microserviceList = fs.readdirSync(microservicePath);
    return microserviceList.map((microservice) =>
        getImageAndVersionFromPath(path.join(microservicePath, microservice, 'base', 'deployment.yaml')),
    ).filter(Boolean);
}

function printImageList(imageList) {
    if (imageList.length) {
        return imageList.map((img) => formatOutput(img)).join('\n');
    } else {
        return 'No images found';
    }
}

function formatVersion(version) {
    if (version.includes('master')) {
        return `\x1b[1m\x1b[42m\x1b[30m ${version.padEnd(9)}\x1b[0m`;
    } else {
        return `\x1b[1m\x1b[43m\x1b[30m ${version.padEnd(9)}\x1b[0m`;
    }
}

function formatOutput([image, version]) {
    return `\x1b[37mImage:\x1b[0m ${image.padEnd(40, ' ')} \x1b[37mVersion:\x1b[0m${formatVersion(version)}`;
}

function printNotMatch(images, expectedImages) {
    const notMatch = expectedImages.filter((expectedImage) => {
        return !images.find((image) => image[0] === expectedImage[0]);
    });
    if (notMatch.length) {
        return `\x1b[1m\n\x1b[31mThe following images are not in the environment:\x1b[0m
${printImageList(notMatch)}
`;
    } else {
        return '';
    }
}

function showImagesAndVersions() {
    const imagesWithVersion = getAllImagesAndVersionsFromEnv();
    const k8sManifestList = getMicroserviceListFromManifest();
    // Print all images with versions
    console.log(`
*********************************************************************************
*                              IMAGES AND VERSIONS                              *
*********************************************************************************

${printImageList(imagesWithVersion)}
${printNotMatch(imagesWithVersion, k8sManifestList)}`);
}

showImagesAndVersions();
